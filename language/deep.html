<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MiniTS Playground</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/theme/dracula.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/hint/show-hint.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            height: 100vh;
            overflow: hidden;
        }

        #app {
            display: flex;
            height: 100vh;
            flex-direction: column;
        }

        .header {
            background: #2d2d2d;
            padding: 15px 20px;
            border-bottom: 1px solid #404040;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            color: #646cff;
            font-size: 24px;
        }

        .header h1 span {
            color: #42b883;
        }

        .run-button {
            background: #42b883;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.3s;
        }

        .run-button:hover {
            background: #33a06f;
        }

        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .editor-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #404040;
            min-width: 0;
        }

        .editor-title {
            background: #252525;
            padding: 10px 15px;
            font-weight: bold;
            border-bottom: 1px solid #404040;
            color: #42b883;
        }

        .CodeMirror {
            height: 100% !important;
            font-size: 14px;
        }

        .output-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }

        .preview-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            border-bottom: 1px solid #404040;
            min-height: 0;
        }

        .preview-header {
            background: #252525;
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #404040;
        }

        .preview-title {
            font-weight: bold;
            color: #646cff;
        }

        .fullscreen-btn {
            background: transparent;
            color: #ccc;
            border: 1px solid #555;
            padding: 4px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .fullscreen-btn:hover {
            background: #555;
        }

        #preview {
            flex: 1;
            background: white;
            overflow: auto;
            border: none;
        }

        .tabs-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .tabs-header {
            background: #252525;
            display: flex;
            border-bottom: 1px solid #404040;
        }

        .tab {
            padding: 10px 15px;
            cursor: pointer;
            border-right: 1px solid #404040;
            background: #2d2d2d;
            color: #999;
            transition: all 0.3s;
        }

        .tab:hover {
            background: #353535;
            color: #ccc;
        }

        .tab.active {
            background: #1a1a1a;
            color: #42b883;
            border-bottom: 2px solid #42b883;
        }

        .tab-content {
            flex: 1;
            overflow: auto;
            padding: 15px;
            background: #1a1a1a;
            white-space: pre-wrap;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 13px;
            line-height: 1.4;
        }

        .error {
            color: #ff6b6b;
        }

        .warning {
            color: #ffd93d;
        }

        .info {
            color: #4fc3f7;
        }

        .success {
            color: #42b883;
        }

        .token-keyword {
            color: #ff79c6;
        }

        .token-operator {
            color: #f8f8f2;
        }

        .token-string {
            color: #f1fa8c;
        }

        .token-number {
            color: #bd93f9;
        }

        .token-comment {
            color: #6272a4;
        }

        .token-function {
            color: #50fa7b;
        }

        .token-variable {
            color: #f8f8f2;
        }

        .json-key {
            color: #ff79c6;
        }

        .json-string {
            color: #f1fa8c;
        }

        .json-number {
            color: #bd93f9;
        }

        .json-boolean {
            color: #bd93f9;
        }

        .fullscreen-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: white;
            z-index: 1000;
            display: none;
        }

        .fullscreen-overlay.active {
            display: block;
        }

        .fullscreen-header {
            background: #252525;
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .fullscreen-content {
            height: calc(100% - 60px);
            overflow: auto;
            border: none;
        }

        .cm-s-dracula span.cm-keyword { color: #ff79c6; }
        .cm-s-dracula span.cm-def { color: #50fa7b; }
        .cm-s-dracula span.cm-variable { color: #f8f8f2; }
        .cm-s-dracula span.cm-variable-2 { color: #bd93f9; }
        .cm-s-dracula span.cm-string { color: #f1fa8c; }
        .cm-s-dracula span.cm-number { color: #bd93f9; }
        .cm-s-dracula span.cm-comment { color: #6272a4; }
        .cm-s-dracula span.cm-operator { color: #f8f8f2; }
        .cm-s-dracula span.cm-type { color: #8be9fd; }
    </style>
</head>
<body>
    <div id="app">
        <div class="header">
            <h1>Mini<span>TS</span> Playground</h1>
            <button class="run-button" onclick="runCode()">Run ▶</button>
        </div>
        
        <div class="main-container">
            <div class="editor-container">
                <div class="editor-title">Editor</div>
                <textarea id="editor"></textarea>
            </div>
            
            <div class="output-container">
                <div class="preview-container">
                    <div class="preview-header">
                        <div class="preview-title">Preview</div>
                        <button class="fullscreen-btn" onclick="togglePreviewFullscreen()">⛶ Fullscreen</button>
                    </div>
                    <iframe id="preview" sandbox="allow-scripts"></iframe>
                </div>
                
                <div class="tabs-container">
                    <div class="tabs-header">
                        <div class="tab active" onclick="switchTab('console', event)">Console</div>
                        <div class="tab" onclick="switchTab('tokens', event)">Tokens</div>
                        <div class="tab" onclick="switchTab('ast', event)">AST</div>
                        <div class="tab" onclick="switchTab('js', event)">Compiled JS</div>
                    </div>
                    <div id="console" class="tab-content active">
                        <div class="info">Ready to compile. Click "Run" to start.</div>
                    </div>
                    <div id="tokens" class="tab-content"></div>
                    <div id="ast" class="tab-content"></div>
                    <div id="js" class="tab-content"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="fullscreen-overlay" id="fullscreenPreview">
        <div class="fullscreen-header">
            <div style="color: white;">Preview (Fullscreen)</div>
            <button class="fullscreen-btn" onclick="togglePreviewFullscreen()">✕ Close</button>
        </div>
        <iframe class="fullscreen-content" id="fullscreenIframe" sandbox="allow-scripts"></iframe>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/javascript/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/hint/show-hint.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/hint/javascript-hint.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/edit/matchbrackets.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/addon/edit/closebrackets.min.js"></script>

    <script>
        // Global variables
        let editor = null;
        let compilerInstance = null;

        // Initialize CodeMirror editor
        function initEditor() {
            const initialState = `// MiniTS with Svelte-style components
let message = "Hello, MiniTS!";
let counter = 0;
let items = ["Apple", "Banana", "Cherry"];
let user = { name: "John", age: 25 };

// Function
function greet(name) {
    return "Hello, " + name + "!";
}

// Conditional statement
if (counter > 0) {
    console.log("Counter is positive");
} else if (counter < 0) {
    console.log("Counter is negative");
} else {
    console.log("Counter is zero");
}

// For loop
for (let i = 0; i < 5; i++) {
    console.log("Iteration:", i);
}

// Array operations
for (let item of items) {
    console.log("Item:", item);
}

// Svelte-style component
function Counter() {
    let count = 0;
    
    function increment() {
        count = count + 1;
        update();
    }
    
    function decrement() {
        count = count - 1;
        update();
    }
    
    // Reactive update (Svelte-style)
    function update() {
        console.log("Count updated:", count);
    }
    
    // Template (Svelte-style)
    return \`
        <div class="counter">
            <h2>Counter: {count}</h2>
            <button onclick="increment()">+</button>
            <button onclick="decrement()">-</button>
            <p>Items: {items.length}</p>
        </div>
    \`;
}

// Render the component
document.body.innerHTML = Counter();`;

            editor = CodeMirror.fromTextArea(document.getElementById('editor'), {
                mode: "javascript",
                theme: "dracula",
                lineNumbers: true,
                lineWrapping: true,
                matchBrackets: true,
                autoCloseBrackets: true,
                extraKeys: {
                    "Ctrl-Space": "autocomplete",
                    "Tab": function(cm) {
                        if (cm.somethingSelected()) {
                            cm.indentSelection("add");
                        } else {
                            cm.replaceSelection("  ", "end");
                        }
                    }
                },
                hintOptions: {
                    hint: CodeMirror.hint.javascript,
                    completeSingle: false
                }
            });
            
            editor.setValue(initialState);
        }

        // Tab switching
        window.switchTab = function(tabName, event) {
            // Update tabs
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // Activate selected tab
            if (event && event.target) {
                event.target.classList.add('active');
            } else {
                // Fallback: find tab by content
                document.querySelector(`.tab[onclick*="${tabName}"]`).classList.add('active');
            }
            document.getElementById(tabName).classList.add('active');
        };

        // Fullscreen preview
        window.togglePreviewFullscreen = function() {
            const overlay = document.getElementById('fullscreenPreview');
            const iframe = document.getElementById('fullscreenIframe');
            const preview = document.getElementById('preview');
            
            if (overlay.classList.contains('active')) {
                overlay.classList.remove('active');
            } else {
                overlay.classList.add('active');
                iframe.srcdoc = preview.srcdoc;
            }
        };

        // Compiler implementation
        class MiniTSCompiler {
            constructor() {
                this.tokens = [];
                this.ast = null;
                this.jsCode = '';
                this.consoleOutput = [];
            }
            
            log(type, message) {
                this.consoleOutput.push({ type, message, timestamp: new Date().toLocaleTimeString() });
                this.updateConsole();
            }
            
            updateConsole() {
                const consoleDiv = document.getElementById('console');
                consoleDiv.innerHTML = this.consoleOutput.map(entry => 
                    `<div class="${entry.type}">[${entry.timestamp}] ${entry.message}</div>`
                ).join('');
            }
            
            tokenize(code) {
                this.log('info', 'Starting tokenization...');
                
                const tokenSpec = [
                    // Whitespace
                    [/^\s+/, null],
                    
                    // Comments
                    [/^\/\/.*/, 'COMMENT'],
                    [/^\/\*[\s\S]*?\*\//, 'COMMENT'],
                    
                    // Keywords
                    [/^\blet\b/, 'LET'],
                    [/^\bfunction\b/, 'FUNCTION'],
                    [/^\breturn\b/, 'RETURN'],
                    [/^\bif\b/, 'IF'],
                    [/^\belse\b/, 'ELSE'],
                    [/^\bfor\b/, 'FOR'],
                    [/^\bof\b/, 'OF'],
                    [/^\bwhile\b/, 'WHILE'],
                    [/^\bbreak\b/, 'BREAK'],
                    [/^\bcontinue\b/, 'CONTINUE'],
                    [/^\btrue\b/, 'BOOLEAN'],
                    [/^\bfalse\b/, 'BOOLEAN'],
                    [/^\bnull\b/, 'NULL'],
                    [/^\bundefined\b/, 'UNDEFINED'],
                    
                    // Types (simplified for now)
                    [/^\bstring\b/, 'TYPE'],
                    [/^\bnumber\b/, 'TYPE'],
                    [/^\bboolean\b/, 'TYPE'],
                    [/^\bArray\b/, 'TYPE'],
                    [/^\bObject\b/, 'TYPE'],
                    
                    // Identifiers
                    [/^[a-zA-Z_$][a-zA-Z0-9_$]*/, 'IDENTIFIER'],
                    
                    // Numbers
                    [/^\d+(\.\d+)?/, 'NUMBER'],
                    
                    // Strings
                    [/^"[^"]*"/, 'STRING'],
                    [/^'[^']*'/, 'STRING'],
                    [/^`[^`]*`/, 'TEMPLATE_STRING'],
                    
                    // Operators
                    [/^[+\-*/%]/, 'OPERATOR'],
                    [/^[=!]==?/, 'OPERATOR'],
                    [/^[=<>!]=?/, 'OPERATOR'],
                    [/^&&|\|\|/, 'OPERATOR'],
                    [/^!/, 'OPERATOR'],
                    [/^\./, 'DOT'],
                    
                    // Punctuation
                    [/^[(){}\[\];,:]/, 'PUNCTUATION'],
                    [/^=>/, 'ARROW']
                ];
                
                let pos = 0;
                this.tokens = [];
                
                while (pos < code.length) {
                    let matched = false;
                    
                    for (const [regex, type] of tokenSpec) {
                        const match = code.slice(pos).match(regex);
                        
                        if (match && type) {
                            this.tokens.push({
                                type,
                                value: match[0],
                                position: pos
                            });
                            pos += match[0].length;
                            matched = true;
                            break;
                        } else if (match) {
                            pos += match[0].length;
                            matched = true;
                            break;
                        }
                    }
                    
                    if (!matched) {
                        this.log('error', `Unexpected character: ${code[pos]} at position ${pos}`);
                        pos++;
                    }
                }
                
                this.log('success', `Tokenization complete. Found ${this.tokens.length} tokens.`);
                this.displayTokens();
                return this.tokens;
            }
            
            parse(tokens) {
                this.log('info', 'Starting parsing...');
                
                let current = 0;
                
                const walk = () => {
                    let token = tokens[current];
                    
                    if (!token) return null;
                    
                    // Variable declaration
                    if (token.type === 'LET') {
                        const node = {
                            type: 'VariableDeclaration',
                            identifier: null,
                            valueType: null,
                            init: null
                        };
                        
                        current++; // Skip let
                        
                        if (tokens[current]?.type === 'IDENTIFIER') {
                            node.identifier = tokens[current].value;
                            current++; // Skip identifier
                        }
                        
                        // Skip type annotation for now
                        if (tokens[current]?.value === ':') {
                            current += 2; // Skip colon and type
                        }
                        
                        // Check for assignment
                        if (tokens[current]?.value === '=') {
                            current++; // Skip =
                            node.init = this.parseExpression(current);
                            if (node.init) {
                                current = node.init.consumed;
                            }
                        }
                        
                        // Skip semicolon if present
                        if (tokens[current]?.value === ';') {
                            current++;
                        }
                        
                        return { node, consumed: current };
                    }
                    
                    // Function declaration
                    if (token.type === 'FUNCTION') {
                        const node = {
                            type: 'FunctionDeclaration',
                            name: null,
                            params: [],
                            body: []
                        };
                        
                        current++; // Skip function
                        
                        if (tokens[current]?.type === 'IDENTIFIER') {
                            node.name = tokens[current].value;
                            current++; // Skip name
                        }
                        
                        // Skip opening parenthesis
                        if (tokens[current]?.value === '(') {
                            current++;
                        }
                        
                        // Parse parameters
                        while (tokens[current] && tokens[current].value !== ')') {
                            if (tokens[current].type === 'IDENTIFIER') {
                                node.params.push(tokens[current].value);
                                current++;
                            }
                            
                            // Skip comma
                            if (tokens[current]?.value === ',') {
                                current++;
                            }
                        }
                        
                        // Skip closing parenthesis
                        if (tokens[current]?.value === ')') {
                            current++;
                        }
                        
                        // Skip opening brace
                        if (tokens[current]?.value === '{') {
                            current++;
                        }
                        
                        // Parse function body
                        while (tokens[current] && tokens[current].value !== '}') {
                            const result = walk();
                            if (result && result.node) {
                                node.body.push(result.node);
                                current = result.consumed;
                            } else {
                                current++;
                            }
                        }
                        
                        // Skip closing brace
                        if (tokens[current]?.value === '}') {
                            current++;
                        }
                        
                        return { node, consumed: current };
                    }
                    
                    // If statement
                    if (token.type === 'IF') {
                        const node = {
                            type: 'IfStatement',
                            test: null,
                            consequent: [],
                            alternate: null
                        };
                        
                        current++; // Skip if
                        
                        // Skip opening parenthesis
                        if (tokens[current]?.value === '(') {
                            current++;
                        }
                        
                        // Parse condition
                        const testResult = this.parseExpression(current);
                        if (testResult) {
                            node.test = testResult.node;
                            current = testResult.consumed;
                        }
                        
                        // Skip closing parenthesis
                        if (tokens[current]?.value === ')') {
                            current++;
                        }
                        
                        // Parse consequent block
                        if (tokens[current]?.value === '{') {
                            current++; // Skip opening brace
                            while (tokens[current] && tokens[current].value !== '}') {
                                const result = walk();
                                if (result && result.node) {
                                    node.consequent.push(result.node);
                                    current = result.consumed;
                                } else {
                                    current++;
                                }
                            }
                            if (tokens[current]?.value === '}') {
                                current++;
                            }
                        }
                        
                        // Check for else
                        if (tokens[current]?.type === 'ELSE') {
                            current++; // Skip else
                            node.alternate = [];
                            
                            if (tokens[current]?.type === 'IF') {
                                // else if
                                const elseIfResult = walk();
                                if (elseIfResult && elseIfResult.node) {
                                    node.alternate.push(elseIfResult.node);
                                    current = elseIfResult.consumed;
                                }
                            } else if (tokens[current]?.value === '{') {
                                // else block
                                current++; // Skip opening brace
                                while (tokens[current] && tokens[current].value !== '}') {
                                    const result = walk();
                                    if (result && result.node) {
                                        node.alternate.push(result.node);
                                        current = result.consumed;
                                    } else {
                                        current++;
                                    }
                                }
                                if (tokens[current]?.value === '}') {
                                    current++;
                                }
                            }
                        }
                        
                        return { node, consumed: current };
                    }
                    
                    // For loop
                    if (token.type === 'FOR') {
                        const node = {
                            type: 'ForStatement',
                            init: null,
                            test: null,
                            update: null,
                            body: []
                        };
                        
                        current++; // Skip for
                        
                        // Skip opening parenthesis
                        if (tokens[current]?.value === '(') {
                            current++;
                        }
                        
                        // Check for for...of loop
                        const nextToken = tokens[current + 1];
                        if (nextToken && nextToken.type === 'OF') {
                            // for...of loop
                            node.type = 'ForOfStatement';
                            const initResult = this.parseExpression(current);
                            if (initResult) {
                                node.init = initResult.node;
                                current = initResult.consumed + 1; // Skip of
                            }
                            
                            // Get the iterable
                            const iterableResult = this.parseExpression(current);
                            if (iterableResult) {
                                node.iterable = iterableResult.node;
                                current = iterableResult.consumed;
                            }
                        } else {
                            // Regular for loop
                            // Parse init
                            if (tokens[current]?.type !== ';') {
                                const initResult = this.parseExpression(current);
                                if (initResult) {
                                    node.init = initResult.node;
                                    current = initResult.consumed;
                                }
                            }
                            
                            // Skip first semicolon
                            if (tokens[current]?.value === ';') {
                                current++;
                            }
                            
                            // Parse test
                            if (tokens[current]?.value !== ';') {
                                const testResult = this.parseExpression(current);
                                if (testResult) {
                                    node.test = testResult.node;
                                    current = testResult.consumed;
                                }
                            }
                            
                            // Skip second semicolon
                            if (tokens[current]?.value === ';') {
                                current++;
                            }
                            
                            // Parse update
                            if (tokens[current]?.value !== ')') {
                                const updateResult = this.parseExpression(current);
                                if (updateResult) {
                                    node.update = updateResult.node;
                                    current = updateResult.consumed;
                                }
                            }
                        }
                        
                        // Skip closing parenthesis
                        if (tokens[current]?.value === ')') {
                            current++;
                        }
                        
                        // Parse body
                        if (tokens[current]?.value === '{') {
                            current++; // Skip opening brace
                            while (tokens[current] && tokens[current].value !== '}') {
                                const result = walk();
                                if (result && result.node) {
                                    node.body.push(result.node);
                                    current = result.consumed;
                                } else {
                                    current++;
                                }
                            }
                            if (tokens[current]?.value === '}') {
                                current++;
                            }
                        } else {
                            // Single statement
                            const result = walk();
                            if (result && result.node) {
                                node.body.push(result.node);
                                current = result.consumed;
                            }
                        }
                        
                        return { node, consumed: current };
                    }
                    
                    // Return statement
                    if (token.type === 'RETURN') {
                        const node = {
                            type: 'ReturnStatement',
                            argument: null
                        };
                        
                        current++; // Skip return
                        
                        // Parse return value
                        const argResult = this.parseExpression(current);
                        if (argResult) {
                            node.argument = argResult.node;
                            current = argResult.consumed;
                        }
                        
                        // Skip semicolon if present
                        if (tokens[current]?.value === ';') {
                            current++;
                        }
                        
                        return { node, consumed: current };
                    }
                    
                    // Expression statement
                    return this.parseExpression(current);
                };
                
                const ast = {
                    type: 'Program',
                    body: []
                };
                
                while (current < tokens.length) {
                    const result = walk();
                    if (result && result.node) {
                        ast.body.push(result.node);
                        current = result.consumed;
                    } else {
                        current++;
                    }
                }
                
                this.ast = ast;
                this.log('success', 'Parsing complete. AST generated.');
                this.displayAST();
                return ast;
            }
            
            parseExpression(startIndex) {
                let current = startIndex;
                let token = tokens[current];
                
                if (!token) return null;
                
                // Handle literals
                if (token.type === 'NUMBER') {
                    const node = {
                        type: 'NumberLiteral',
                        value: parseFloat(token.value)
                    };
                    current++;
                    return { node, consumed: current };
                }
                
                if (token.type === 'STRING') {
                    const node = {
                        type: 'StringLiteral',
                        value: token.value.slice(1, -1)
                    };
                    current++;
                    return { node, consumed: current };
                }
                
                if (token.type === 'TEMPLATE_STRING') {
                    const node = {
                        type: 'TemplateLiteral',
                        value: token.value.slice(1, -1)
                    };
                    current++;
                    return { node, consumed: current };
                }
                
                if (token.type === 'BOOLEAN') {
                    const node = {
                        type: 'BooleanLiteral',
                        value: token.value === 'true'
                    };
                    current++;
                    return { node, consumed: current };
                }
                
                if (token.type === 'IDENTIFIER') {
                    const node = {
                        type: 'Identifier',
                        name: token.value
                    };
                    current++;
                    
                    // Check for function call
                    if (tokens[current]?.value === '(') {
                        const callNode = {
                            type: 'CallExpression',
                            callee: node,
                            arguments: []
                        };
                        
                        current++; // Skip '('
                        
                        // Parse arguments
                        while (tokens[current] && tokens[current].value !== ')') {
                            const argResult = this.parseExpression(current);
                            if (argResult) {
                                callNode.arguments.push(argResult.node);
                                current = argResult.consumed;
                            }
                            
                            // Skip comma
                            if (tokens[current]?.value === ',') {
                                current++;
                            }
                        }
                        
                        if (tokens[current]?.value === ')') {
                            current++;
                        }
                        
                        return { node: callNode, consumed: current };
                    }
                    
                    // Check for member access
                    if (tokens[current]?.value === '.') {
                        current++; // Skip '.'
                        if (tokens[current]?.type === 'IDENTIFIER') {
                            const memberNode = {
                                type: 'MemberExpression',
                                object: node,
                                property: {
                                    type: 'Identifier',
                                    name: tokens[current].value
                                }
                            };
                            current++;
                            return { node: memberNode, consumed: current };
                        }
                    }
                    
                    return { node, consumed: current };
                }
                
                // Array literal
                if (token.value === '[') {
                    const node = {
                        type: 'ArrayExpression',
                        elements: []
                    };
                    
                    current++; // Skip '['
                    
                    while (tokens[current] && tokens[current].value !== ']') {
                        const elemResult = this.parseExpression(current);
                        if (elemResult) {
                            node.elements.push(elemResult.node);
                            current = elemResult.consumed;
                        }
                        
                        // Skip comma
                        if (tokens[current]?.value === ',') {
                            current++;
                        }
                    }
                    
                    if (tokens[current]?.value === ']') {
                        current++;
                    }
                    
                    return { node, consumed: current };
                }
                
                // Object literal
                if (token.value === '{') {
                    const node = {
                        type: 'ObjectExpression',
                        properties: []
                    };
                    
                    current++; // Skip '{'
                    
                    while (tokens[current] && tokens[current].value !== '}') {
                        if (tokens[current].type === 'IDENTIFIER') {
                            const key = tokens[current].value;
                            current++;
                            
                            if (tokens[current]?.value === ':') {
                                current++; // Skip ':'
                            }
                            
                            const valueResult = this.parseExpression(current);
                            if (valueResult) {
                                node.properties.push({
                                    key,
                                    value: valueResult.node
                                });
                                current = valueResult.consumed;
                            }
                        }
                        
                        // Skip comma
                        if (tokens[current]?.value === ',') {
                            current++;
                        }
                    }
                    
                    if (tokens[current]?.value === '}') {
                        current++;
                    }
                    
                    return { node, consumed: current };
                }
                
                // Binary expression
                if (token.type === 'OPERATOR' || ['<', '>', '<=', '>=', '==', '!=', '===', '!==', '+', '-', '*', '/', '%', '&&', '||'].includes(token.value)) {
                    // For now, just skip operator
                    current++;
                    return this.parseExpression(current);
                }
                
                return null;
            }
            
            compileToJS(ast) {
                this.log('info', 'Starting compilation to JavaScript...');
                
                const generate = (node) => {
                    if (!node) return '';
                    
                    switch (node.type) {
                        case 'Program':
                            return node.body.map(generate).filter(Boolean).join('\n');
                            
                        case 'VariableDeclaration':
                            let js = `let ${node.identifier}`;
                            if (node.init) {
                                js += ` = ${generate(node.init)}`;
                            }
                            return js + ';';
                            
                        case 'FunctionDeclaration':
                            const params = node.params.join(', ');
                            let func = `function ${node.name}(${params}) {\n`;
                            func += node.body.map(generate).map(line => '  ' + line).join('\n');
                            func += '\n}';
                            return func;
                            
                        case 'IfStatement':
                            let ifJS = `if (${generate(node.test)}) {\n`;
                            ifJS += node.consequent.map(generate).map(line => '  ' + line).join('\n');
                            ifJS += '\n}';
                            if (node.alternate) {
                                if (Array.isArray(node.alternate)) {
                                    ifJS += ' else {\n';
                                    ifJS += node.alternate.map(generate).map(line => '  ' + line).join('\n');
                                    ifJS += '\n}';
                                } else {
                                    ifJS += ` else ${generate(node.alternate)}`;
                                }
                            }
                            return ifJS;
                            
                        case 'ForStatement':
                            let forJS = `for (`;
                            forJS += node.init ? generate(node.init).replace(/;$/, '') : '';
                            forJS += `; ${node.test ? generate(node.test) : ''}; `;
                            forJS += node.update ? generate(node.update).replace(/;$/, '') : '';
                            forJS += `) {\n`;
                            forJS += node.body.map(generate).map(line => '  ' + line).join('\n');
                            forJS += '\n}';
                            return forJS;
                            
                        case 'ForOfStatement':
                            let forOfJS = `for (let ${generate(node.init)} of ${generate(node.iterable)}) {\n`;
                            forOfJS += node.body.map(generate).map(line => '  ' + line).join('\n');
                            forOfJS += '\n}';
                            return forOfJS;
                            
                        case 'ReturnStatement':
                            return `return ${generate(node.argument)};`;
                            
                        case 'ExpressionStatement':
                            return generate(node.expression) + ';';
                            
                        case 'CallExpression':
                            const args = node.arguments.map(generate).join(', ');
                            return `${generate(node.callee)}(${args})`;
                            
                        case 'MemberExpression':
                            return `${generate(node.object)}.${generate(node.property)}`;
                            
                        case 'NumberLiteral':
                        case 'BooleanLiteral':
                            return String(node.value);
                            
                        case 'StringLiteral':
                            return `"${node.value}"`;
                            
                        case 'TemplateLiteral':
                            return `\`${node.value}\``;
                            
                        case 'ArrayExpression':
                            const elements = node.elements.map(generate).join(', ');
                            return `[${elements}]`;
                            
                        case 'ObjectExpression':
                            const props = node.properties.map(prop => 
                                `${prop.key}: ${generate(prop.value)}`
                            ).join(', ');
                            return `{${props}}`;
                            
                        case 'Identifier':
                            return node.name;
                            
                        case 'BinaryExpression':
                            return `${generate(node.left)} ${node.operator} ${generate(node.right)}`;
                            
                        default:
                            return '';
                    }
                };
                
                this.jsCode = generate(ast);
                
                // Add basic runtime for Svelte-style templates
                const runtime = `
// Template processor for Svelte-style templates
function processTemplate(template, context) {
    return template.replace(/\\{([^}]+)\\}/g, (match, expr) => {
        try {
            // Create a function with the expression and context
            const func = new Function(...Object.keys(context), \`return \${expr}\`);
            return func(...Object.values(context));
        } catch (e) {
            console.error('Template error:', e);
            return match;
        }
    });
}

// Console wrapper for better logging
const _console = {
    log: (...args) => {
        const output = args.map(arg => 
            typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)
        ).join(' ');
        try {
            window.parent.postMessage({ type: 'console', message: output }, '*');
        } catch(e) {}
    },
    error: (...args) => {
        const output = args.map(arg => 
            typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)
        ).join(' ');
        try {
            window.parent.postMessage({ type: 'error', message: output }, '*');
        } catch(e) {}
    },
    warn: (...args) => {
        const output = args.map(arg => 
            typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)
        ).join(' ');
        try {
            window.parent.postMessage({ type: 'warning', message: output }, '*');
        } catch(e) {}
    }
};

// Override console
window.console = _console;

// Global context
const context = {};

// Start execution
try {
    ${this.jsCode}
} catch (error) {
    console.error('Execution error:', error.message, error.stack);
}
`;
                
                this.jsCode = runtime;
                this.log('success', 'Compilation to JavaScript complete.');
                this.displayJS();
                return this.jsCode;
            }
            
            displayTokens() {
                const tokensDiv = document.getElementById('tokens');
                if (this.tokens.length === 0) {
                    tokensDiv.innerHTML = '<div class="info">No tokens generated yet.</div>';
                    return;
                }
                
                const tokenHTML = this.tokens.map(token => {
                    let cssClass = 'token-' + token.type.toLowerCase();
                    let displayValue = token.value;
                    
                    // Escape HTML in the value
                    displayValue = displayValue
                        .replace(/&/g, '&amp;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;')
                        .replace(/"/g, '&quot;')
                        .replace(/'/g, '&#039;');
                    
                    // Handle newlines and tabs
                    displayValue = displayValue.replace(/\n/g, '\\n').replace(/\t/g, '\\t');
                    
                    return `<div class="${cssClass}">${token.type}: "${displayValue}" (pos: ${token.position})</div>`;
                }).join('');
                tokensDiv.innerHTML = tokenHTML;
            }
            
            displayAST() {
                const astDiv = document.getElementById('ast');
                astDiv.innerHTML = this.formatJSON(this.ast);
            }
            
            displayJS() {
                const jsDiv = document.getElementById('js');
                // Escape HTML in JS code
                let escapedCode = this.jsCode
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;');
                
                jsDiv.innerHTML = '<div class="token-comment">// Compiled JavaScript:</div>\n' + escapedCode;
            }
            
            formatJSON(obj) {
                const json = JSON.stringify(obj, null, 2);
                return json
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?)/g, match => {
                        let cls = 'json-number';
                        if (/:$/.test(match)) {
                            cls = 'json-key';
                        } else if (/^"/.test(match)) {
                            if (/:$/.test(match.slice(0, -1))) {
                                cls = 'json-key';
                            } else {
                                cls = 'json-string';
                            }
                        } else if (/true|false/.test(match)) {
                            cls = 'json-boolean';
                        } else if (/null/.test(match)) {
                            cls = 'json-null';
                        }
                        return `<span class="${cls}">${match}</span>`;
                    });
            }
        }
        
        // Handle console messages from iframe
        window.addEventListener('message', (event) => {
            if (event.data && (event.data.type === 'console' || event.data.type === 'error' || event.data.type === 'warning')) {
                if (compilerInstance) {
                    compilerInstance.log(event.data.type, event.data.message);
                }
            }
        });
        
        // Main run function
        window.runCode = function() {
            compilerInstance = new MiniTSCompiler();
            
            // Clear previous output
            compilerInstance.consoleOutput = [];
            
            // Get code from editor
            let code = editor.getValue();
            
            compilerInstance.log('info', 'Starting compilation pipeline...');
            
            try {
                // Step 1: Tokenization
                const tokens = compilerInstance.tokenize(code);
                
                // Step 2: Parsing
                const ast = compilerInstance.parse(tokens);
                
                // Step 3: Compilation
                const jsCode = compilerInstance.compileToJS(ast);
                
                // Step 4: Execution in preview
                const preview = document.getElementById('preview');
                const fullscreenIframe = document.getElementById('fullscreenIframe');
                
                // Escape the <\/script> tag in the JavaScript code
                const escapedJSCode = jsCode.replace(/<\/script>/gi, '<\\/script>');
                
                const html = `<!DOCTYPE html>
<html>
<head>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            margin: 0;
            background: #f5f5f5;
        }
        .counter {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            text-align: center;
        }
        button {
            margin: 5px;
            padding: 10px 20px;
            background: #646cff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        button:hover {
            background: #535bf2;
        }
        .error {
            color: #ff6b6b;
            padding: 10px;
            background: #fff5f5;
            border-radius: 5px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div id="app"></div>
    <script>
        ${escapedJSCode}
    <\/script>
</body>
</html>`;
                
                preview.srcdoc = html;
                fullscreenIframe.srcdoc = html;
                
                compilerInstance.log('success', 'Code executed successfully in preview.');
                switchTab('console', { target: document.querySelector('.tab[onclick*="console"]') });
                
            } catch (error) {
                compilerInstance.log('error', `Compilation failed: ${error.message}`);
                console.error('Compiler error:', error);
            }
        };
        
        // Initialize when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            initEditor();
            
            // Run initial example after a short delay
            setTimeout(() => {
                runCode();
            }, 500);
        });
    </script>
</body>
</html>